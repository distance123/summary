	创建型模式，共五种：	工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
	结构型模式，共七种：	适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
	行为型模式，共十一种：	策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、
							状态模式、访问者模式、中介者模式、解释器模式。
							
	每种设计模式有它存在使用的独特环境,滥用不如不用,首先理解使用该模式最主要是解决一个什么问题
	
	代理模式:
		静态代理
			被代理对象和代理对象需要实现同一个接口或者继承相同父类
		   	静态代理执行思路
		   		代理对象里面调用被代理对象需要增强的方法
		   		在方法前后手动添加代码 来实现方法的增强
		动态代理
		  	JDK 代理
		  		  代理对象和目标对象不需要实现同一个接口,但目标对象必须实现一个接口
		  		  操作字节码文件动态增强方法
		    cglib 代理
		  		 目标对象不需要实现接口	代理对象是目标对象的子类
		
	
	工厂模式: 			  		
		目的:为了解耦合,把对象的创建和使用分开,
			比如 在class A中需要调用class B 的方法,没必要在class A中执行创建 class B,完全可以交给工厂类去创建
		是否需要为设计中的每一个类都配备一个工厂类?
			如果产品类很简单,不存在太多变数,构造过程也很简单,无需为其提供工厂类,直接实例化就可以,
			有时候我们创建一个对象不只是简单调用其构造函数,还需要设置一些参数,可能还需要配置环境.
		工厂模式分为三种  
			工厂方法	:传入特定id 动态生成所需要的类	 
			静态工厂方法:工厂类中使用静态方法去生产所需要的类
			抽象工厂方法:提供一个工厂接口,生产类的工厂去实现该接口,更具有灵活性,增加类时,创建一个工厂类即可
	
	享元模式:
		目的:实现对象的共享,共享池,减少内存的开销,通常与工厂模式一起使用
		
		
	单例模式:
		目的:确保类只有一个实例,并提供一个全局访问点;
		饿汉式：自身就是线程安全的
		懒汉式：自身非线程安全，需要做一些处理 volatile 控制变量，synchronized 控制方法里面逻辑
				一个控制了变化,一个控制了访问
				
	适配器模式:
		目的:消除由于接口不匹配所造成的类的兼容性问题
		类的适配器模式: 希望一个类转换成为满足另外一个新接口的类时,创建一个新类,继承原有类,实现新的接口;
		对象适配器模式: 希望一个对象转换成满足另一个满足新街口的对象时,可以创建一个Wrapper类,持有原类的一个实例
					    在Wapper类的方法中,调用实例的方法
		接口适配器模式: 不希望实现一个接口中所有的方法时,可以创建一个抽象类Wrapper,实现所有方法,
						我们写别的类是继承抽象类即可.
	
	装饰者模式:
		和代理的区别:
		目的:给对象动态增加一些新功能,
			 装饰对象和被装饰对象实现同一接口,装饰对象持有被装饰对象的是例.
			 
	桥接模式:
			软件系统中,由于类自身的逻辑,它具有多个维度的变化,传统做法通过类继承来实现,但是会导致类的结构过于复杂
		继承关系太多,难于维护,扩展性太差,违背了单一职责原则(一个类只有一个引起它变化的原因),可以用桥接模式解决;
		目的:将抽象部分与实现部分分离,使他们都可以独立的变化
			重构系统,优化实体类,优化一些工具类的时候可以用到
		与装饰者的区别:
			装饰者把比基类多的部分放在单独的类里面,来适应新功能增加的需要
			桥接把原来的基类的实现化细节抽象出来,在构造到一个实现化的结构中
			把原来的基类改造成一个抽象化的等级结构,
		
	组合模式:
	
	模板方法模式:
		目的:不改变算法结构,将一些步骤延迟到子类中进行,重定义改算法的某些特定步骤
		基于继承的代码复用	行为模式
		    子类,抽象父类 
	
	观察者模式:
		效果:当一个对象发生改变时,其他依赖该对象的对象都会收到通知;
	
	迭代子模式:
	
	责任链模式(Chain of Responsibility):	有点面向过程的感觉
		在隐瞒客户端的情况下，对系统进行动态的调整.
		我们常写的if else,判断时,如果由于流程改变
		
		
		
		
		
		
		
		
		
		